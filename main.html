<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Koning Dodo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --accent: #ff8c00; /* Oranje */
      --mint: #24d17e;   /* Groen  */
      --bg1: #04110d; --bg2: #021a1a;
      --glass: rgba(0, 25, 15, 0.55);
      --glass-strong: rgba(0, 40, 20, 0.65);
      --text: #f2fff7; --muted: #c7f1df;
      --card: rgba(0, 60, 30, 0.6); --card-hover: rgba(0, 90, 40, 0.8);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px; --radius-lg: 22px;
      --ring: 0 0 0 2px color-mix(in srgb, var(--accent) 70%, transparent);
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 10% 10%, #0d5a3a30 0%, transparent 60%),
        radial-gradient(1000px 700px at 90% 20%, #0a2a5a33 0%, transparent 60%),
        linear-gradient(120deg, var(--bg1), var(--bg2));
      overflow-x: hidden;
    }

    /* Cinematic BG matching index */
    .bg{position:fixed; inset:0; z-index:-3; background:url('https://i.imgur.com/y9tD43R.jpeg') center/cover no-repeat fixed; filter:contrast(1.05) saturate(1.1) brightness(.72);}  
    .bg::after{content:""; position:absolute; inset:0; background:radial-gradient(1000px 600px at 50% 20%, transparent 0%, rgba(0,0,0,.45) 70%), linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.6));}
    .sheen{position:fixed; inset:-20%; z-index:-2; pointer-events:none; mix-blend-mode:soft-light; opacity:.6; background:conic-gradient(from 0deg,#0a3822,transparent 30%,#092a3a 60%,transparent 85%); animation:spin 50s linear infinite;}
    @keyframes spin{to{transform:rotate(360deg)}}
    #fxCanvas { position: fixed; inset: 0; z-index: -1; display:block; }

    header {
      position: sticky; top: 0; z-index: 50;
      background: linear-gradient(0deg, transparent, rgba(0,0,0,.5));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid color-mix(in srgb, var(--accent) 40%, transparent);
    }
    .nav { max-width: 1200px; margin: 0 auto; padding: 14px 20px; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .brand { display: flex; align-items: center; gap: 12px; text-decoration: none; color: var(--text); }
    .brand img { height: 64px; filter: drop-shadow(0 6px 12px rgba(0,0,0,.5)); }
    .brand-title { font-family: Orbitron, Inter, sans-serif; letter-spacing: .06em; font-weight: 800; font-size: clamp(18px, 4vw, 26px); }
    .badge { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: linear-gradient(90deg, var(--accent), var(--mint)); color: #00150a; font-weight: 800; box-shadow: var(--shadow); }

    main { max-width: 1200px; margin: 16px auto 60px; padding: 0 20px; display: grid; grid-template-columns: 1fr 360px; gap: 22px; align-items: start; }

    /* Betslip */
    .betslip { position: sticky; top: 16px; align-self: start; width: 100%; background: linear-gradient(180deg, var(--glass-strong), rgba(0,0,0,.25)); border-radius: var(--radius-lg); border: 1px solid color-mix(in srgb, var(--mint) 35%, transparent); box-shadow: var(--shadow); padding: 16px 16px 18px; isolation: isolate; }
    .betslip::before { content:""; position:absolute; inset: -1px; border-radius: inherit; pointer-events:none; background: conic-gradient(from 180deg, color-mix(in srgb, var(--accent) 60%, transparent), transparent 20%, color-mix(in srgb, var(--mint) 55%, transparent) 55%, transparent 80%); filter: blur(12px); opacity: .35; z-index:-1; }
    .betslip h2 { margin: 0 0 6px; font-size: 20px; letter-spacing:.02em; color: var(--muted); }
    .field { display:flex; flex-direction:column; gap:6px; margin: 10px 0 8px; }
    .input, .btn, .pill { width: 100%; border: 0; border-radius: 12px; padding: 12px 14px; font-size: 15px; }
    .input { background: rgba(255,255,255,.07); color: var(--text); outline: none; box-shadow: inset 0 0 0 1px rgba(255,255,255,.07); }
    .input:focus { box-shadow: inset 0 0 0 2px var(--accent), 0 0 0 4px rgba(255,140,0,.15); }
    .row { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .muted { color: #d5ffef; opacity: .85; font-size: 13px; }
    .stat { font-weight: 800; }
    .btn { background: linear-gradient(90deg, var(--accent), var(--mint)); color: #00150a; font-weight: 900; cursor: pointer; transition: transform .15s ease, box-shadow .2s ease, filter .2s ease; box-shadow: 0 8px 20px rgba(255, 140, 0, .25); }
    .btn:disabled { opacity: .55; cursor:not-allowed; filter: grayscale(.4); }
    .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 26px rgba(255, 140, 0, .35); }

    #bets p { margin: 8px 0; background: rgba(0,0,0,.25); padding: 8px 10px; border-radius: 10px; }
    .remove { margin-left: 8px; background:#900; color:#fff; padding: 4px 8px; border-radius: 8px; font-size: 12px; border:0; cursor:pointer; opacity:.9; }
    .remove:hover { opacity:1; filter:brightness(1.05); }
    #stakeWarning, #payoutWarning { color: #ff4343; font-weight: 800; display:none; }
    .bet-info { margin-top: 12px; font-size: 12px; color: #ffe6b5; text-align:center; opacity:.9; }

    /* Matches */
    .matches { min-height: 70vh; }
    .league { background: linear-gradient(180deg, var(--glass), rgba(0,0,0,.2)); border-radius: var(--radius-lg); border: 1px solid color-mix(in srgb, var(--mint) 25%, transparent); padding: 10px; box-shadow: var(--shadow); margin-bottom: 18px; }
    .league-header { display:flex; align-items:center; justify-content:space-between; gap: 10px; cursor:pointer; user-select:none; padding: 6px 8px; border-radius: 12px; }
    .league-header:focus-visible { outline: none; box-shadow: var(--ring); }
    .league-title { display:flex; align-items:center; gap: 10px; }
    .league-icon { width:28px; height:28px; border-radius: 50%; box-shadow: 0 0 0 2px rgba(255, 140, 0, .35); }
    .toggle-icon { font-size: 20px; transition: transform .25s ease; color: var(--muted); }
    .toggle-icon.open { transform: rotate(90deg); color: var(--accent); }
    .match-list { overflow: hidden; max-height: 0; opacity: 0; transition: max-height .35s ease, opacity .35s ease; padding: 0 6px; }
    .match-list.open { opacity: 1; }

    .match { background: var(--card); border-radius: 14px; padding: 10px; margin: 8px 0; transition: transform .12s ease, background .25s ease, box-shadow .25s ease; cursor: pointer; position: relative; }
    .match:hover { transform: translateY(-1px); background: var(--card-hover); box-shadow: 0 10px 26px rgba(0,0,0,.25); }
    .match .title { display:flex; align-items:center; justify-content:space-between; gap: 12px; }
    .live { display:flex; align-items:center; gap:6px; font-weight: 800; color:#ff7171; }
    .dot { width:8px; height:8px; border-radius:50%; background:#ff4343; box-shadow: 0 0 10px #ff4343; animation: blink 1s ease-in-out infinite; }
    @keyframes blink { 50% { opacity:.4; filter:brightness(.7); } }
    .meta { font-size: 12px; opacity:.9; color: var(--muted); margin: 4px 0 8px; }

    .odds { display:flex; flex-wrap: wrap; gap: 6px; }
    .odds .pick { background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.1); padding: 6px 10px; border-radius: 10px; font-weight: 800; color: #fff; cursor: pointer; transition: transform .12s ease, box-shadow .2s ease, background .2s ease; }
    .odds .pick:hover { transform: translateY(-1px) scale(1.02); box-shadow: 0 6px 18px rgba(0,0,0,.25); }

    .fab { position: fixed; right: 16px; bottom: 16px; z-index: 70; display:none; }
    .fab button { border:0; border-radius: 999px; padding: 14px 18px; font-weight: 900; box-shadow: 0 12px 24px rgba(0,0,0,.35); background: linear-gradient(90deg, var(--accent), var(--mint)); color: #00150a; cursor:pointer; }

    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
      .betslip { position: fixed; left: 0; right: 0; bottom: 0; top: auto; border-radius: 18px 18px 0 0; transform: translateY(66%); transition: transform .35s ease; z-index: 60; }
      .betslip.open { transform: translateY(0%); }
      .fab { display:block; }
    }

    @media (prefers-reduced-motion: reduce) {
      .match:hover { transform:none; }
      .btn, .odds .pick { transition: none; }
      .sheen{animation:none}
    }
  </style>
</head>
<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="sheen" aria-hidden="true"></div>
  <canvas id="fxCanvas" aria-hidden="true"></canvas>

  <header>
    <div class="nav">
      <a class="brand" href="#" aria-label="Koning Dodo">
        <img src="https://i.imgur.com/YpEK9A2.png" alt="Koning Dodo logo" />
        <div class="brand-title">KONING DODO <span class="badge">Roleplay WEDKANTOOR</span></div>
      </a>
    </div>
  </header>

  <main>
    <section class="matches" id="matches" aria-live="polite"></section>

    <aside class="betslip" id="betslip" aria-label="Betslip" aria-expanded="false">
      <h2>Jouw Betslip</h2>
      <div class="field">
        <label for="bettorName" class="muted">Discord naam</label>
        <input class="input" type="text" id="bettorName" placeholder="@jouw-naam" required />
      </div>
      <div id="bets"></div>
      <div class="row" style="margin-top:8px;">
        <span class="muted">Totaal Odds:</span>
        <span class="stat" id="totalOdds">1.00</span>
      </div>
      <div class="row">
        <span class="muted">Potentiële Uitbetaling:</span>
        <span class="stat">€<span id="potentialPayout">0,00</span></span>
      </div>
      <p id="payoutWarning"></p>

      <div class="field">
        <label for="stake" class="muted">Inzet (€)</label>
        <input class="input" type="number" id="stake" placeholder="75000 – 500000" min="75000"  max="500000" />
        <span id="stakeWarning"></span>
      </div>

      <button class="btn" id="sendBtn" onclick="sendToDiscord()">Verstuur naar Discord</button>
      <p class="bet-info">Minimale inzet 75K • Maximale inzet 500K • Maximale uitbetaling 3.0M</p>
    </aside>
  </main>

  <div class="fab"><button id="toggleSlip">Betslip</button></div>

  <script>
    // Client-side keys zichtbaar. Overweeg Vercel functions + ENV secrets.
    const apiKey = "e7f774dc1fd8d38f2e66f1ae6128ac47";
    const webhookURL = "https://discord.com/api/webhooks/1404901242307608706/KpY04R63ezeTL6WQCFvtLd1HwlA9_JeR0GhtfpVniqMgsOV6lhLtQMuV3-bHeM1LfxwU";

    // Audio: ping + subtiele whoosh
    let AC; function getAC(){ AC = AC || new (window.AudioContext||window.webkitAudioContext)(); return AC; }
    function coinPing(v=0.22, dur=0.12, type='triangle', f=920){
      const ac = getAC(); const o = ac.createOscillator(); const g = ac.createGain();
      o.type = type; o.frequency.value = f; o.connect(g); g.connect(ac.destination);
      const t = ac.currentTime; g.gain.setValueAtTime(v, t); g.gain.exponentialRampToValueAtTime(0.001, t + dur);
      o.start(t); o.stop(t + dur + 0.02);
    }
    // Nieuwe, zachte whoosh (gefilterde brown noise + compressor, zachte ADSR)
    function whoosh(vol=0.045, dur=0.34){
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
      const ac = getAC(); const t = ac.currentTime;
      const n = Math.max(1, Math.floor(ac.sampleRate * Math.max(0.2, dur)));
      const buf = ac.createBuffer(1, n, ac.sampleRate);
      const data = buf.getChannelData(0);
      // Brown noise (zachter, minder "sissend" dan white noise)
      let lastOut = 0;
      for (let i=0;i<n;i++){
        const white = Math.random()*2 - 1;
        lastOut = (lastOut + 0.02*white) / 1.02;
        data[i] = lastOut * 1.6;
      }
      const src = ac.createBufferSource(); src.buffer = buf;

      const lp = ac.createBiquadFilter(); lp.type = 'lowpass';
      lp.frequency.setValueAtTime(1800, t); lp.frequency.linearRampToValueAtTime(900, t + dur);

      const hp = ac.createBiquadFilter(); hp.type = 'highpass';
      hp.frequency.setValueAtTime(90, t); hp.frequency.linearRampToValueAtTime(60, t + dur);

      const comp = ac.createDynamicsCompressor();
      comp.threshold.value = -26; comp.knee.value = 24; comp.ratio.value = 4; comp.attack.value = 0.005; comp.release.value = 0.22;

      const g = ac.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(vol, t + 0.03);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      const pan = ac.createStereoPanner ? ac.createStereoPanner() : null;
      if (pan) pan.pan.setValueAtTime((Math.random()*0.6)-0.3, t);

      // chain
      src.connect(lp); lp.connect(hp); hp.connect(comp); comp.connect(g);
      if (pan){ g.connect(pan); pan.connect(ac.destination); } else { g.connect(ac.destination); }

      src.start(t); src.stop(t + dur + 0.02);
    }
    
    // League icons
    function svgBadge(text, bg="#0b3d91") {
      const svg = `
      <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'>
        <defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='${bg}'/><stop offset='100%' stop-color='#062b62'/></linearGradient></defs>
        <circle cx='32' cy='32' r='30' fill='url(#g)' stroke='#ff8c00' stroke-width='3'/>
        <text x='32' y='38' font-family='Arial, Helvetica, sans-serif' font-size='22' fill='#ffffff' text-anchor='middle' font-weight='bold'>${text}</text>
      </svg>`;
      return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
    }
    function leagueIconSrc(name) {
      switch (name) {
        case "Eredivisie": return svgBadge("NL", "#006400");
        case "Champions League": return svgBadge("UCL", "#0b3d91");
        case "UEFA Europa League": return svgBadge("UEL", "#5a3e0a");
        case "WK (FIFA)": return svgBadge("WK", "#11605a");
        case "Jupiler Pro League": return svgBadge("BE", "#c8102e");
        case "MMA / UFC": return svgBadge("UFC", "#d20a0a");
        default: return svgBadge("KD", "#444");
      }
    }

    // ——— Leagues (volgorde aangepast) ———
    const leagues = {
      "Eredivisie": "soccer_netherlands_eredivisie",
      "Jupiler Pro League": "soccer_belgium_first_div",
      "WK (FIFA)": [
        "soccer_fifa_world_cup_qualifiers_europe",
        "soccer_fifa_world_cup_qualifiers_south_america",
        "soccer_fifa_world_cup"
      ],
      "Champions League": ["soccer_uefa_champs_league_qualification", "soccer_uefa_champs_league"],
      "UEFA Europa League": ["soccer_uefa_europa_league"],
      "MMA / UFC": "mma_mixed_martial_arts"
    };

    let betslip = [];
    // Expose on window so the webhook metadata injector can access it
    window.betslip = betslip;
    let loadedLeagues = {};
    const MAX_INZET = 500000, MIN_INZET = 75000, MAX_PAYOUT = 3000000, ODDS_ADJUSTMENT = 0.900;
    const MIN_FLOOR_LOW = 1.09, MIN_FLOOR_HIGH = 1.12;

    function randomMinFloor(){ const val = MIN_FLOOR_LOW + Math.random() * (MIN_FLOOR_HIGH - MIN_FLOOR_LOW); return Math.round(val * 100) / 100; }
    function adjustedOdds(price){ let adj = (price || 1) * ODDS_ADJUSTMENT; const floor = randomMinFloor(); if (adj < floor) adj = floor; return adj; }
    function formatDateTimeToNL(utcDate){ const date = new Date(utcDate); return date.toLocaleString('nl-NL', { timeZone: 'Europe/Amsterdam', day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }); }
    function formatCurrency(amount){ return amount.toLocaleString('nl-NL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }
    function getMatchMinute(startTime){ const start = new Date(startTime); const now = new Date(); const diffMinutes = Math.floor((now - start) / 60000); if (diffMinutes >= 0 && diffMinutes <= 120) { return `${diffMinutes}'`; } return null; }
    function isWithinNext7Days(dateString){ const matchDate = new Date(dateString); const now = new Date(); const sevenDaysLater = new Date(now.getTime() + 7*24*60*60*1000); return matchDate >= now && matchDate <= sevenDaysLater; }

    function createLeagueElement(name, key) {
      const listId = "list-" + (Array.isArray(key) ? key.join("_") : key).replace(/[^a-zA-Z0-9_]/g, "_");
      const wrap = document.createElement("div");
      wrap.className = "league";
      wrap.innerHTML = `
        <div class="league-header" tabindex="0" role="button" aria-expanded="false" aria-controls="${listId}">
          <div class="league-title">
            <img class="league-icon" alt="${name} icon" src="${leagueIconSrc(name)}"/>
            <h2 style="margin:0;font-size:18px;">${name}</h2>
          </div>
          <span class="toggle-icon" aria-hidden="true">▶</span>
        </div>
        <div class="match-list" id="${listId}"></div>
      `;
      const header = wrap.querySelector('.league-header');
      const toggleIcon = wrap.querySelector('.toggle-icon');
      const matchList = wrap.querySelector('.match-list');

      header.addEventListener('click', () => { whoosh(0.05,0.18,650,1100); toggleLeague(key, toggleIcon, matchList, header); });
      header.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); header.click(); } });
      return wrap;
    }

    async function toggleLeague(key, toggleIcon, matchList, headerEl) {
      const expanded = !toggleIcon.classList.contains('open');
      toggleIcon.classList.toggle('open', expanded);
      headerEl.setAttribute('aria-expanded', String(expanded));

      if (expanded) {
        const keyId = Array.isArray(key) ? key.join('_') : key;
        if (!loadedLeagues[keyId]) {
          matchList.innerHTML = `<p class="muted" style="padding:10px 6px;">Laden...</p>`;
          try {
            const matches = await fetchMatches(key);
            const isMMA = (Array.isArray(key) ? key : [key]).some(k => String(k).startsWith('mma_'));
            renderMatches(matches, matchList, isMMA);
            loadedLeagues[keyId] = true;
          } catch (e) {
            console.error(e);
            matchList.innerHTML = `<p style="color:#ff7171;padding:10px 6px;">Fout bij laden wedstrijden.</p>`;
          }
        }
        matchList.classList.add('open');
        matchList.style.maxHeight = matchList.scrollHeight + 'px';
      } else {
        matchList.style.maxHeight = '0px';
        matchList.classList.remove('open');
      }
    }

    async function fetchMatches(leagueKeyOrKeys) {
      const keys = Array.isArray(leagueKeyOrKeys) ? leagueKeyOrKeys : [leagueKeyOrKeys];
      const requests = keys.map(key => {
        const url = `https://api.the-odds-api.com/v4/sports/${key}/odds/?apiKey=${apiKey}&regions=eu&markets=h2h&oddsFormat=decimal`;
        return fetch(url).then(res => { if (!res.ok) throw new Error(`API error ${res.status} for ${key}`); return res.json(); });
      });
      const resultsArrays = await Promise.all(requests);
      const combined = [];
      resultsArrays.forEach((arr, idx) => {
        const key = keys[idx];
        (arr || []).forEach(ev => { try { ev.sport_key = key; } catch(_){} });
        combined.push(...(arr || []));
      });
      const seen = new Set();
      const deduped = combined.filter(m => { if (seen.has(m.id)) return false; seen.add(m.id); return true; });
      deduped.sort((a, b) => new Date(a.commence_time) - new Date(b.commence_time));
      return deduped;
    }

    function renderMatches(matches, container, isMMA) {
      container.innerHTML = "";
      const upcoming = (matches || []).filter(m => isWithinNext7Days(m.commence_time));
      if (!upcoming.length) { container.innerHTML = "<p class=\"muted\" style=\"padding:10px 6px;\">Geen wedstrijden/gevechten in de komende 7 dagen.</p>"; return; }

      upcoming.forEach(match => {
        const bookmaker = match.bookmakers?.[0];
        const market = bookmaker?.markets?.find(m => m.key === 'h2h') || bookmaker?.markets?.[0];
        const outcomes = market?.outcomes || [];
        if (!outcomes.length) return;

        const home = match.home_team || (isMMA ? (outcomes?.[0]?.name || 'Deelnemer A') : 'Thuis');
        const away = match.away_team || (isMMA ? (outcomes?.[1]?.name || 'Deelnemer B') : 'Uit');
        const startTimeNL = formatDateTimeToNL(match.commence_time);
        const minute = getMatchMinute(match.commence_time);

        const el = document.createElement('div');
        el.className = 'match';
        el.innerHTML = `
          <div class=\"title\">
            <p style=\"margin:0;font-weight:800;\">${home} - ${away}</p>
            ${minute ? `<span class=\"live\"><span class=\"dot\"></span>${minute}</span>` : ''}
          </div>
          <p class=\"meta\"><em>${startTimeNL}</em></p>
          <div class=\"odds\"></div>
        `;

        const sortedOutcomes = isMMA || !match.home_team ? [...outcomes] : [...outcomes].sort((a, b) => { if (a.name === match.home_team) return -1; if (b.name === match.home_team) return 1; return 0; });

        const oddsDiv = el.querySelector('.odds');
        sortedOutcomes.forEach(outcome => {
          const adj = adjustedOdds(outcome.price);
          const btn = document.createElement('button');
          btn.className = 'pick';
          btn.textContent = `${outcome.name} (${adj.toFixed(2)})`;
          btn.addEventListener('click', (ev) => { addBet(match, { ...outcome, price: adj, marketKey: 'h2h' }); ripple(ev); coinPing(0.18,0.08,'sine',1080); });
          oddsDiv.appendChild(btn);
        });

        container.appendChild(el);
      });

      requestAnimationFrame(() => { const parent = container; parent.style.maxHeight = parent.scrollHeight + 'px'; });
    }

    function addBet(match, outcome) {
      const betId = `${match.id}_h2h_${outcome.name}`;
      if (betslip.some(b => b.id === betId)) { toast('Deze selectie staat al in je betslip.'); return; }
      betslip.push({ id: betId, match, outcome, odds: outcome.price, sk: (match && (match.sport_key || match.__sport_key)) || null });
      window.betslip = betslip;
      updateBetslip();
    }

    function updateBetslip() {
      const betsDiv = document.getElementById('bets');
      betsDiv.innerHTML = '';
      let totalOdds = 1;
      betslip.forEach(bet => {
        totalOdds *= bet.odds;
        const home = bet.match.home_team || 'Deelnemer A';
        const away = bet.match.away_team || 'Deelnemer B';
        const p = document.createElement('p');
        p.textContent = `${home} - ${away} • Winnaar: ${bet.outcome.name} (${bet.odds.toFixed(2)})`;
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove';
        removeBtn.textContent = 'Verwijder';
        removeBtn.addEventListener('click', () => { betslip = betslip.filter(b => b.id !== bet.id);
        window.betslip = betslip;
        updateBetslip(); });
        p.appendChild(removeBtn);
        betsDiv.appendChild(p);
      });

      document.getElementById('totalOdds').textContent = totalOdds.toFixed(2);
      const inzet = parseFloat(document.getElementById('stake').value);
      const potential = inzet && inzet > 0 ? inzet * totalOdds : 0;

      const stakeInput = document.getElementById('stake');
      const stakeWarning = document.getElementById('stakeWarning');
      const payoutElem = document.getElementById('potentialPayout');
      const payoutWarning = document.getElementById('payoutWarning');
      const sendBtn = document.getElementById('sendBtn');

      stakeWarning.style.display = 'none';
      payoutWarning.style.display = 'none';
      stakeInput.style.boxShadow = '';
      payoutElem.style.color = '';

      let valid = true;

      if (!inzet || inzet < MIN_INZET) {
        stakeInput.style.boxShadow = 'inset 0 0 0 2px #ff4343, 0 0 0 4px rgba(255,67,67,.2)';
        stakeWarning.textContent = `Minimale inzet is €${formatCurrency(MIN_INZET)}.`;
        stakeWarning.style.display = 'block';
        valid = false;
      }
      if (inzet > MAX_INZET) {
        stakeInput.style.boxShadow = 'inset 0 0 0 2px #ff4343, 0 0 0 4px rgba(255,67,67,.2)';
        stakeWarning.textContent = `Maximale inzet is €${formatCurrency(MAX_INZET)}.`;
        stakeWarning.style.display = 'block';
        valid = false;
      }
      if (potential > MAX_PAYOUT && inzet > 0) {
        payoutElem.style.color = '#ff4343';
        payoutWarning.textContent = `Maximale uitbetaling is €${formatCurrency(MAX_PAYOUT)}. Je potentiële uitbetaling is €${formatCurrency(potential)}.`;
        payoutWarning.style.display = 'block';
      } else {
        payoutElem.style.color = '';
        payoutWarning.style.display = 'none';
      }

      document.getElementById('potentialPayout').textContent = formatCurrency(potential);
      sendBtn.disabled = !valid || betslip.length === 0;
    }
    document.getElementById('stake').addEventListener('input', updateBetslip);

    function sendToDiscord() {
      const bettorName = document.getElementById('bettorName').value.trim();
      if (!bettorName) { toast("Vul alsjeblieft je Discord naam in."); return; }
      if (!bettorName.startsWith('@')) { toast("Je Discord naam moet beginnen met '@'."); return; }
      if (betslip.length === 0) { toast("Je hebt nog geen weddenschappen toegevoegd."); return; }

      const inzet = parseFloat(document.getElementById('stake').value);
      if (!inzet || inzet <= 0) { toast("Vul een geldige inzet in."); return; }
      if (inzet < MIN_INZET || inzet > MAX_INZET) { toast(`Inzet moet tussen €${formatCurrency(MIN_INZET)} en €${formatCurrency(MAX_INZET)} liggen.`); return; }

      const totalOdds = parseFloat(document.getElementById('totalOdds').textContent);
      const potential = inzet * totalOdds;

      let payoutText = `€${formatCurrency(potential)}`;
      if (potential > MAX_PAYOUT) { payoutText += ` (Max uitbetaling €${formatCurrency(MAX_PAYOUT)})`; }

      let description = `**Wedder:** ${bettorName}\n**Inzet:** €${formatCurrency(inzet)}\n**Totaal Odds:** ${totalOdds.toFixed(2)}\n**Potentiële Uitbetaling:** ${payoutText}\n\n**Weddenschappen:**\n`;
      betslip.forEach(bet => {
        const matchDate = formatDateTimeToNL(bet.match.commence_time);
        const home = bet.match.home_team || 'Deelnemer A';
        const away = bet.match.away_team || 'Deelnemer B';
        description += `- ${home} - ${away} (${matchDate}) • Winnaar: ${bet.outcome.name} (${bet.odds.toFixed(2)})\n`;
      });

      const payload = { username: 'Koning Dodo', embeds: [{ title: 'Nieuwe weddenschap', description, color: 5763719, footer: { text: 'Koning Dodo' }, timestamp: new Date().toISOString() }] };

      fetch(webhookURL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
        .then(res => {
          if (res.ok) {
            toast('Weddenschap verstuurd naar Discord!');
            coinPing(0.3,0.12,'triangle',980); // ping bij succes
            party(); // confetti effect
            betslip = [];
            window.betslip = betslip;
            updateBetslip();
            document.getElementById('bettorName').value = '';
            document.getElementById('stake').value = '';
          } else { toast('Er is een fout opgetreden bij het versturen.'); }
        })
        .catch(() => toast('Er is een fout opgetreden bij het versturen.'));
    }

    // Ripple, toast, confetti, particles, bottom-sheet toggle
    function ripple(ev) {
      const btn = ev.currentTarget;
      const r = document.createElement('span');
      const rect = btn.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height);
      r.style.position = 'absolute'; r.style.left = (ev.clientX - rect.left - size/2) + 'px'; r.style.top = (ev.clientY - rect.top - size/2) + 'px';
      r.style.width = r.style.height = size + 'px'; r.style.borderRadius = '50%'; r.style.pointerEvents = 'none';
      r.style.background = 'radial-gradient(circle, rgba(255,255,255,.35), transparent 60%)';
      r.style.transform = 'scale(0)'; r.style.transition = 'transform .4s ease, opacity .6s ease'; r.style.opacity = '1';
      btn.style.position = 'relative'; btn.appendChild(r);
      requestAnimationFrame(() => { r.style.transform = 'scale(1.6)'; r.style.opacity = '0'; });
      setTimeout(() => r.remove(), 600);
    }

    let toastEl;
    function toast(msg) {
      if (!toastEl) {
        toastEl = document.createElement('div');
        toastEl.style.position = 'fixed'; toastEl.style.left = '50%'; toastEl.style.bottom = '20px'; toastEl.style.transform = 'translateX(-50%)';
        toastEl.style.padding = '10px 14px'; toastEl.style.borderRadius = '12px'; toastEl.style.background = 'rgba(0,0,0,.7)'; toastEl.style.color = '#fff'; toastEl.style.zIndex = '80';
        toastEl.style.fontWeight = '800'; toastEl.style.boxShadow = '0 10px 24px rgba(0,0,0,.4)'; document.body.appendChild(toastEl);
      }
      toastEl.textContent = msg; toastEl.style.opacity = '0';
      toastEl.style.transition = 'opacity .15s ease'; requestAnimationFrame(() => { toastEl.style.opacity = '1'; });
      clearTimeout(toastEl._t); toastEl._t = setTimeout(() => { toastEl.style.opacity = '0'; }, 1800);
    }

    const canvas = document.getElementById('fxCanvas');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let W, H; let particles = []; let confetti = []; let motionOK = matchMedia('(prefers-reduced-motion: no-preference)').matches;

    function resize() { W = canvas.width = Math.floor(innerWidth * dpr); H = canvas.height = Math.floor(innerHeight * dpr); canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px'; }
    window.addEventListener('resize', resize); resize();

    function spawnParticles(n=70) { particles.length = 0; for (let i=0;i<n;i++) { particles.push({ x: Math.random()*W, y: Math.random()*H, r: (Math.random()*2+0.5)*dpr, vx: (Math.random()-.5)*0.25*dpr, vy: (Math.random()*0.2+0.05)*dpr, a: Math.random()*0.6+0.15 }); } }
    function party() { for (let i=0;i<140;i++) { const angle = Math.random()*Math.PI*2; const speed = (Math.random()*2+1) * dpr; confetti.push({ x: W/2, y: H*0.7, w: (Math.random()*3+1)*dpr, h: (Math.random()*8+3)*dpr, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 2*dpr, life: 120+Math.random()*60, hue: Math.random()*360 }); } }
    function tick() {
      ctx.clearRect(0,0,W,H);
      ctx.globalAlpha = 0.6;
      particles.forEach(p => { p.x += p.vx; p.y += p.vy; if (p.y > H) { p.y = -10; p.x = Math.random()*W; } if (p.x < 0) p.x = W; if (p.x > W) p.x = 0; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fillStyle = 'rgba(36, 209, 126, 0.35)'; ctx.fill(); });
      ctx.globalAlpha = 1;
      confetti.forEach((c, i) => { c.x += c.vx; c.y += c.vy; c.vy += 0.02*dpr; c.life -= 1; if (c.life <= 0) confetti[i] = null; ctx.save(); ctx.translate(c.x, c.y); ctx.rotate((120-c.life)/12); ctx.fillStyle = `hsl(${c.hue} 90% 60% / .9)`; ctx.fillRect(-c.w/2, -c.h/2, c.w, c.h); ctx.restore(); });
      confetti = confetti.filter(Boolean);
      requestAnimationFrame(tick);
    }
    if (motionOK) { spawnParticles(); tick(); }

    const betslipEl = document.getElementById('betslip');
    const toggleSlipBtn = document.getElementById('toggleSlip');
    toggleSlipBtn?.addEventListener('click', () => betslipEl.classList.toggle('open'));

    (async function loadAllLeagues() { const matchesContainer = document.getElementById('matches'); for (const [name, key] of Object.entries(leagues)) { matchesContainer.appendChild(createLeagueElement(name, key)); } })();
  </script>

<script>
// Inject metadata embed into Discord webhook payload for auto-settle
(function(){
  const __origFetch = window.fetch;
  window.fetch = function(url, options){
    try {
      if (typeof url === 'string' && url.includes('discord.com/api/webhooks') && options && options.method === 'POST' && options.body){
        const payload = JSON.parse(options.body);
        if (payload && Array.isArray(payload.embeds)){
          const meta = {
            v: 1,
            l: (window.betslip || []).map(function(bet){
              return {
                sk: (bet.match && (bet.match.sport_key || bet.match.__sport_key)) || null,
                id: bet.match && bet.match.id,
                ct: bet.match && bet.match.commence_time,
                h: bet.match && (bet.match.home_team || (bet.outcome && bet.outcome.name)),
                a: bet.match && (bet.match.away_team || null),
                m: 'h2h',
                p: bet.outcome && bet.outcome.name,
                pr: bet.odds
              };
            }),
            created_at: new Date().toISOString()
          };
          payload.embeds.push({
            title: 'metadata',
            description: '```json\n' + JSON.stringify(meta) + '\n```'
          });
          options.body = JSON.stringify(payload);
        }
      }
    } catch (e) { /* noop */ }
    return __origFetch.apply(this, arguments);
  };
})();
</script>

</body>
</html>
